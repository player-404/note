## 组合式Api

#### 1.为什么要使用组合时Api

方便将单独的功能提取为模块

获取用书数据（提取为单独的模块）：

```js
import { fetchUserRepositories } from '@/api/repositories'
import { ref, onMounted, watch } from 'vue'

export default function useUserRepositories(user) {
  const repositories = ref([])
  const getUserRepositories = async () => {
    repositories.value = await fetchUserRepositories(user.value)
  }

  onMounted(getUserRepositories)
  watch(user, getUserRepositories)

  return {
    repositories,
    getUserRepositories
  }
}
```

搜索功能(提取为单独的模块):

```JS
import { ref, computed } from 'vue'

export default function useRepositoryNameSearch(repositories) {
  const searchQuery = ref('')
  const repositoriesMatchingSearchQuery = computed(() => {
    return repositories.value.filter(repository => {
      return repository.name.includes(searchQuery.value)
    })
  })

  return {
    searchQuery,
    repositoriesMatchingSearchQuery
  }
}
```

之后便可以在组件中使用他们了：

```js
import useUserRepositories from '@/composables/useUserRepositories'
import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch'
import { toRefs } from 'vue'

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  setup (props) {
    const { user } = toRefs(props)

    const { repositories, getUserRepositories } = useUserRepositories(user)

    const {
      searchQuery,
      repositoriesMatchingSearchQuery
    } = useRepositoryNameSearch(repositories)

    return {
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: repositoriesMatchingSearchQuery,
      getUserRepositories,
      searchQuery,
    }
  },
  data () {
    return {
      filters: { ... }, // 3
    }
  },
  computed: {
    filteredRepositories () { ... }, // 3
  },
  methods: {
    updateFilters () { ... }, // 3
  }
}
```

这样不仅使代码逻辑更加清晰，也增加了功能的可复用性



#### 2.setup

`setup` 是围绕 `beforeCreate` 和 `created` 生命周期钩子运行的

参数：

* props

  接受父组件的传值

  可直接在模板中使用

  ```javascript
  <template>
   	<h1>{{title}}</h1> 	  
   </template>
  <script>
      props: {
      title: {
        type: String,
      },
    },    	
  </script>
  ```

  props的值是响应式的，不可解构，否则会失去响应性，可以使用 `toRef`或`toRefs`

  ```javascript
  <script>
      import {toRrfs} from 'vue'
   	export default {
  	props: {
          title: String
      },
          setup(props, context) {
              const {title} = toRef(props);
              return {
                  title
              }
          }
  }   
   </script>
  ```

  * context 

    context 为对象，它包含以下几个属性

    * attrs：组件上绑定的属性
    * slots：插槽
    * emit: 自定义事件
    * expose

    ```js
    <script>
     	export default {
    	setup(props, context) {
             //非响应式对象
        	const $attrs = context.attrs;
    
        	//非响应式对象
        	const $slots = context.slots;
    
       		 //自定义事件
        	const $emit = context.emit;
        }
    }   
     </script>
    ```

    > *setup 执行时，组件实例尚未创建 可以访问 props slots emit attrs 无法访问 data computed methods refs*

​	由于context只是普通对象，并不是响应式的，所以context 可以使用 `解构`语法

```js
<script>
   export default {
	setup(props, {attrs, slots, emit, expose}) {
        
    }
} 
   </script>
```



**provide/inject**

在setup中使用 provide/inject 需`外部引用`

* provide 接受两个参数
  * name : 传递数据的名称  [type: String]
  * value:  传递的值
* inject 接受两个参数
  * name: 接受的属性名 [type: String]
  * defaultValue:  默认值

```vue
<script>
import { provide } from 'vue'
 export default {
 setup() {
 	provide('msg', '这是一条需要传递的数据')
	}
 }
</script>
```

```vue
<script>
import { inject } from 'vue';
    export default {
        setup() {
            inject('msg', "这里是默认值")
        }
    }
</script>
```

> 这样传递的数据是不具备响应式的



**给 provide/inject 添加响应式**

通过 `ref` || `reactive` 为 传递的数据添加相应式

```vue
<script>
    import { ref, provide} from 'vue'
	export default {
        setup() {
            const msg = ref('这是一条响应式数据');
            provide('msg', msg);
        }
    }
</script>
```

```vue
<script>
import {inject} from 'vue';
    export default {
        setup() {
            const msg = inject('msg');
            return {msg}
        }
    }
</script>
```



**修改 provide/inject 传递的响应式的值**

当我们需要修该传递的响应式的值时，`建议在该组件内修改, 并创建方法单独修改`

```vue
<script>
 import { ref } from 'vue'
export default {
	setup() }{
		const msg = ref('这里是一条响应式数据');
		provide('msg', msg)
	},
	methods() {
		change() {
			this.msg.value = '修改了响应式数据'
		}
	}
}
</script>
```

在`注入数据的组件`(子组件/子孙组件)中需要修改时，使用`provide`传递修改方法
```vue
<script>
import {ref, provide} from 'vue';
	export default {
		setup() {
			const msg = ref("这是一条响应式数据");
			const change = () => {
				this.msg.value = "修改了响应式数据";
			}
			provide('msg', msg);
			procide('change', change);

			return {
				msg,
				change
			}
		}
	}
</script>	
```
在子组件中 | 子孙组件 中使用 `inject` 接受该事件，`接收的事件可以直接绑定使用`
```vue
<script>
import { inject } from 'vue'
	export default {
		setup() {
			const change = inject('change');
			return {
				change
			}
		}
	}
</script>
```


#### 3.响应式api

**基础api**
* reactive
`reacive`的响应式转换是深层的，它会将所有属性转换为响应式
```vue
<script>
import { reactive } from 'vue';
export default {
	setup() {
		const obj = reactive({count: 1});
		return { obj }
	}
}
</script>
```

即使是之后添加的属性也是响应式的
```vue
<script>
import {reactive } from 'vue';
export default {
setup() {
		const obj = reactive({count: 1});
		// 该属性同样是响应式的
		obl.num = 2;
	}
}
</script>
```

> 当将 [ref](https://v3.cn.vuejs.org/api/refs-api.html#ref) 分配给 `reactive` property 时，ref 将被自动解包。

* [readonly](https://v3.cn.vuejs.org/api/basic-reactivity.html#readonly)
给变量设置`readobly`使得变量无法改变, `readonly`是深层的，任何属性都无法修改
```vue
	<script>

import { reactive, readonly } from "vue";

export default {

 setup() {

 let value = readonly(reactive({ count: 1 }));

 let value1 = reactive({ count: 1 });

 const change = () => {

 value.count = 2; // => 无法修改， 会弹出警告

 };

 const change1 = () => {

 value1.count = 2;

 };

 return { change, change1 };

 },

};

</script>
```

* [isProxy](https://v3.cn.vuejs.org/api/basic-reactivity.html#isproxy)
检查对象是否是由 [`reactive`](https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive) 或 [`readonly`](https://v3.cn.vuejs.org/api/basic-reactivity.html#readonly) 创建的 proxy。



**Refs**
* ref
* unref
* toRef
* toRefs
