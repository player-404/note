## 组合式Api

#### 1.为什么要使用组合时Api

方便将单独的功能提取为模块

获取用书数据（提取为单独的模块）：

```js
import { fetchUserRepositories } from '@/api/repositories'
import { ref, onMounted, watch } from 'vue'

export default function useUserRepositories(user) {
  const repositories = ref([])
  const getUserRepositories = async () => {
    repositories.value = await fetchUserRepositories(user.value)
  }

  onMounted(getUserRepositories)
  watch(user, getUserRepositories)

  return {
    repositories,
    getUserRepositories
  }
}
```

搜索功能(提取为单独的模块):

```JS
import { ref, computed } from 'vue'

export default function useRepositoryNameSearch(repositories) {
  const searchQuery = ref('')
  const repositoriesMatchingSearchQuery = computed(() => {
    return repositories.value.filter(repository => {
      return repository.name.includes(searchQuery.value)
    })
  })

  return {
    searchQuery,
    repositoriesMatchingSearchQuery
  }
}
```

之后便可以在组件中使用他们了：

```js
import useUserRepositories from '@/composables/useUserRepositories'
import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch'
import { toRefs } from 'vue'

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  setup (props) {
    const { user } = toRefs(props)

    const { repositories, getUserRepositories } = useUserRepositories(user)

    const {
      searchQuery,
      repositoriesMatchingSearchQuery
    } = useRepositoryNameSearch(repositories)

    return {
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: repositoriesMatchingSearchQuery,
      getUserRepositories,
      searchQuery,
    }
  },
  data () {
    return {
      filters: { ... }, // 3
    }
  },
  computed: {
    filteredRepositories () { ... }, // 3
  },
  methods: {
    updateFilters () { ... }, // 3
  }
}
```

这样不仅使代码逻辑更加清晰，也增加了功能的可复用性



#### 2.setup

`setup` 是围绕 `beforeCreate` 和 `created` 生命周期钩子运行的

参数：

* props

  接受父组件的传值

  可直接在模板中使用

  ```javascript
  <template>
   	<h1>{{title}}</h1> 	  
   </template>
  <script>
      props: {
      title: {
        type: String,
      },
    },    	
  </script>
  ```

  props的值是响应式的，不可解构，否则会失去响应性，可以使用 `toRef`或`toRefs`

  ```javascript
  <script>
      import {toRrfs} from 'vue'
   	export default {
  	props: {
          title: String
      },
          setup(props, context) {
              const {title} = toRef(props);
              return {
                  title
              }
          }
  }   
   </script>
  ```

  * context 

    context 为对象，它包含以下几个属性

    * attrs：组件上绑定的属性
    * slots：插槽
    * emit: 自定义事件
    * expose

    ```js
    <script>
     	export default {
    	setup(props, context) {
             //非响应式对象
        	const $attrs = context.attrs;
    
        	//非响应式对象
        	const $slots = context.slots;
    
       		 //自定义事件
        	const $emit = context.emit;
        }
    }   
     </script>
    ```

    > *setup 执行时，组件实例尚未创建 可以访问 props slots emit attrs 无法访问 data computed methods refs*

​	由于context只是普通对象，并不是响应式的，所以context 可以使用 `解构`语法

```js
<script>
   export default {
	setup(props, {attrs, slots, emit, expose}) {
        
    }
} 
   </script>
```

