## 组合式Api

#### 1.为什么要使用组合时Api

方便将单独的功能提取为模块

获取用书数据（提取为单独的模块）：

```js
import { fetchUserRepositories } from '@/api/repositories'
import { ref, onMounted, watch } from 'vue'

export default function useUserRepositories(user) {
  const repositories = ref([])
  const getUserRepositories = async () => {
    repositories.value = await fetchUserRepositories(user.value)
  }

  onMounted(getUserRepositories)
  watch(user, getUserRepositories)

  return {
    repositories,
    getUserRepositories
  }
}
```

搜索功能(提取为单独的模块):

```JS
import { ref, computed } from 'vue'

export default function useRepositoryNameSearch(repositories) {
  const searchQuery = ref('')
  const repositoriesMatchingSearchQuery = computed(() => {
    return repositories.value.filter(repository => {
      return repository.name.includes(searchQuery.value)
    })
  })

  return {
    searchQuery,
    repositoriesMatchingSearchQuery
  }
}
```

之后便可以在组件中使用他们了：

```js
import useUserRepositories from '@/composables/useUserRepositories'
import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch'
import { toRefs } from 'vue'

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  setup (props) {
    const { user } = toRefs(props)

    const { repositories, getUserRepositories } = useUserRepositories(user)

    const {
      searchQuery,
      repositoriesMatchingSearchQuery
    } = useRepositoryNameSearch(repositories)

    return {
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: repositoriesMatchingSearchQuery,
      getUserRepositories,
      searchQuery,
    }
  },
  data () {
    return {
      filters: { ... }, // 3
    }
  },
  computed: {
    filteredRepositories () { ... }, // 3
  },
  methods: {
    updateFilters () { ... }, // 3
  }
}
```

这样不仅使代码逻辑更加清晰，也增加了功能的可复用性



#### 2.setup

`setup` 是围绕 `beforeCreate` 和 `created` 生命周期钩子运行的

参数：

* props

  接受父组件的传值

  可直接在模板中使用

  ```javascript
  <template>
   	<h1>{{title}}</h1> 	  
   </template>
  <script>
      props: {
      title: {
        type: String,
      },
    },    	
  </script>
  ```

  props的值是响应式的，不可解构，否则会失去响应性，可以使用 `toRef`或`toRefs`

  ```javascript
  <script>
      import {toRrfs} from 'vue'
   	export default {
  	props: {
          title: String
      },
          setup(props, context) {
              const {title} = toRef(props);
              return {
                  title
              }
          }
  }   
   </script>
  ```

  * context 

    context 为对象，它包含以下几个属性

    * attrs：组件上绑定的属性
    * slots：插槽
    * emit: 自定义事件
    * expose

    ```js
    <script>
     	export default {
    	setup(props, context) {
             //非响应式对象
        	const $attrs = context.attrs;
    
        	//非响应式对象
        	const $slots = context.slots;
    
       		 //自定义事件
        	const $emit = context.emit;
        }
    }   
     </script>
    ```

    > *setup 执行时，组件实例尚未创建 可以访问 props slots emit attrs 无法访问 data computed methods refs*

​	由于context只是普通对象，并不是响应式的，所以context 可以使用 `解构`语法

```js
<script>
   export default {
	setup(props, {attrs, slots, emit, expose}) {
        
    }
} 
   </script>
```



**provide/inject**

在setup中使用 provide/inject 需`外部引用`

* provide 接受两个参数
  * name : 传递数据的名称  [type: String]
  * value:  传递的值
* inject 接受两个参数
  * name: 接受的属性名 [type: String]
  * defaultValue:  默认值

```vue
<script>
import { provide } from 'vue'
 export default {
 setup() {
 	provide('msg', '这是一条需要传递的数据')
	}
 }
</script>
```

```vue
<script>
import { inject } from 'vue';
    export default {
        setup() {
            inject('msg', "这里是默认值")
        }
    }
</script>
```

> 这样传递的数据是不具备响应式的



**给 provide/inject 添加响应式**

通过 `ref` || `reactive` 为 传递的数据添加相应式

```vue
<script>
    import { ref, provide} from 'vue'
	export default {
        setup() {
            const msg = ref('这是一条响应式数据');
            provide('msg', msg);
        }
    }
</script>
```

```vue
<script>
import {inject} from 'vue';
    export default {
        setup() {
            const msg = inject('msg');
            return {msg}
        }
    }
</script>
```



**修改 provide/inject 传递的响应式的值**

当我们需要修该传递的响应式的值时，`建议在该组件内修改, 并创建方法单独修改`

```vue
<script>
 import { ref } from 'vue'
export default {
	setup() }{
		const msg = ref('这里是一条响应式数据');
		provide('msg', msg)
	},
	methods() {
		change() {
			this.msg.value = '修改了响应式数据'
		}
	}
}
</script>
```

在`注入数据的组件`(子组件/子孙组件)中需要修改时，使用`provide`传递修改方法
```vue
<script>
import {ref, provide} from 'vue';
	export default {
		setup() {
			const msg = ref("这是一条响应式数据");
			const change = () => {
				this.msg.value = "修改了响应式数据";
			}
			provide('msg', msg);
			procide('change', change);

			return {
				msg,
				change
			}
		}
	}
</script>	
```
在子组件中 | 子孙组件 中使用 `inject` 接受该事件，`接收的事件可以直接绑定使用`
```vue
<script>
import { inject } from 'vue'
	export default {
		setup() {
			const change = inject('change');
			return {
				change
			}
		}
	}
</script>
```


#### 3.响应式api

**基础api**
* reactive
`reacive`的响应式转换是深层的，它会将所有属性转换为响应式 ^91ccc2
```vue
<script>
import { reactive } from 'vue';
export default {
	setup() {
		const obj = reactive({count: 1});
		return { obj }
	}
}
</script>
```

即使是之后添加的属性也是响应式的
```vue
<script>
import {reactive } from 'vue';
export default {
setup() {
		const obj = reactive({count: 1});
		// 该属性同样是响应式的
		obl.num = 2;
	}
}
</script>
```

> 当将 [ref](https://v3.cn.vuejs.org/api/refs-api.html#ref) 分配给 `reactive` property 时，ref 将被自动解包。
> `reavtive` 使用结构语法会使其`失去响应性`

* [readonly](https://v3.cn.vuejs.org/api/basic-reactivity.html#readonly)
**接收一个对象(响应式或纯对象)**，readonly 是深层次的；
```vue
<script>

import { reactive, readonly } from "vue";

export default {

 setup() {

 let value = readonly(reactive({ count: 1 }));

 let value1 = reactive({ count: 1 });

 const change = () => {

 value.count = 2; // => 无法修改， 会弹出警告

 };

 const change1 = () => {

 value1.count = 2;

 };

 return { change, change1 };

 },

};

</script>
```

* [isProxy](https://v3.cn.vuejs.org/api/basic-reactivity.html#isproxy)
检查对象是否是由 [`reactive`](https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive) 或 [`readonly`](https://v3.cn.vuejs.org/api/basic-reactivity.html#readonly) 创建的 proxy。

* [isReadOnly](https://v3.cn.vuejs.org/api/basic-reactivity.html#isreadonly)
检查对象是否是由 [`readonly`](https://v3.cn.vuejs.org/api/basic-reactivity.html#readonly) 创建的只读代理。

* [isReactive](https://v3.cn.vuejs.org/api/basic-reactivity.html#isreactive)
检查对象是否是由 [`reactive`](https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive) 创建的响应式代理。
> 如果该代理是 [`readonly`](https://v3.cn.vuejs.org/api/basic-reactivity.html#readonly) 创建的，但包裹了由 [`reactive`](https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive) 创建的另一个代理，它也会返回 `true`。

* [toRaw](https://v3.cn.vuejs.org/api/basic-reactivity.html#toraw)
返回响应式的`原始对象`

* [makeRaw](https://v3.cn.vuejs.org/api/basic-reactivity.html#markraw)
标记一个对象，使其永远不会转换为 proxy。返回对象本身。

* [shallowReactive](https://v3.cn.vuejs.org/api/basic-reactivity.html#shallowreactive)
使数据为响应式，但不是深层的，不会使嵌套对象也是响应式的

* [shallowReadonly](https://v3.cn.vuejs.org/api/basic-reactivity.html#shallowreadonly)
创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。

**Refs**
* ref
接受一个内部值并返回一个响应式且可变的` ref 对象`。ref 对象仅有一个 `.value` property，指向该内部值。
```vue
<script>
import {ref} from 'vue';
export default {
	setup() {
		const num = ref(1);
		console.log(num.value); => 1
		return {num}
	}
}
</script>
```
如果将对象分配给ref值，那么它将会被 `reavtive` 函数处理 `深层的响应式对象`
```vue
<script>
import {ref, isReactive} from 'vue'
export default {
	setup() {
		const num = ref({name: '张三'});
		console.log(isReactive(num)); => true
	}
}
</script>
```

* unref
如果参数是一个 [`ref`](https://v3.cn.vuejs.org/api/refs-api.html#ref)，则返回内部值，否则返回参数本身。这是 `val = isRef(val) ? val.value : val` 的语法糖函数。
```vue
<script>

import { ref, unref } from "vue";

export default {

 setup() {

 const num = ref({ name: 1 });

 console.log(unref(num).name); => 1

 },

};

</script>
```

* toRef
可以用来为源响应式对象上的某个 property `新创建`一个 [`ref`](https://v3.cn.vuejs.org/api/refs-api.html#ref)。然后，ref 可以被传递，`它会保持对其源 property 的响应式连接。`
```vue
<script>

import { reactive, toRef } from "vue";

export default {

 setup() {

 const state = reactive({

 foo: 2,

 bar: 1,

 });

 const foo = toRef(state, "foo"); // 创建一个新的ref，此ref与源响应式对象保持连接

 const add = () => {

 foo.value++;

 console.log("state", state.foo);

 console.log("foo", foo.value);

 };  

 return { add };

 },

};

</script>
```

* toRefs
将`响应式对象`转换`普通对象`, 其中结果对象的`每个 property `都是指向原始对象相应 property 的 [ref](https://v3.cn.vuejs.org/api/refs-api.html#ref)

```vue
<script>

import { isReadonly, isRef, isReactive, reactive, toRefs } from "vue";

export default {

 setup() {

 // 响应式对象使用结构语法会使其失去响应式，属性会被解构为普通属性

 const state = reactive({ name1: "张三", name2: "李四" });

 //使用 toRefs 将响应式对象的每个属性 转换为 ref

 const refs = toRefs(state);

 console.log(refs.name1.value, refs.name2.value);

 //refs 对象不载是响应式对象

 console.log(isReactive(refs));

 },

};

</script>
```

> 1. 响应式对象会被转换为普通对象
 >2. 原响应式对象中的每个属性都会转换为 ref
 >3. ref 与 原响应式对象会链接起来，`值会同步`

