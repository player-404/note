# 组件通信

#### 1.父子组件通信

##### 父传子

​	a) 在子组件绑定传递数据的属性，子组件只用`props`接受, 传递变量时，使用`v-bind`绑定

```vue
//父组件
<template>
  <!-- 父传子 -->
  <Son title="你好" content="李颖河" />
</template>

//子组件
<template>
  <h1>{{ title }}</h1>
  <div>{{ content }}</div>
</template>

<script>
export default {
  //接受父组件传递的数据
  props: ["title", "content"],
};
</script>
```

​	b) 不动态绑定时，默认传递的是字符传，以下情况需要动态绑定数据

​	 i) `动态数据`

```vue
<template>
  <!-- 父传子 -->
  <Son title="你好" content="李颖河" :message="msg"/>
</template>

<script>
import Son from "./Son.vue";
export default {
  components: {
    Son,
  },
  data() {
    return {
      msg: 'fuck'
    }
  }
};
</script>
```

​	 i) `数字`

```vue
<Son title="你好" content="李颖河" :message="msg" :num="9999"/>
```

​	 i) `布尔值`

```vue
<Son title="你好" content="李颖河" :message="msg" :num="9999" :show="false"/>
```

​	 i) `数组`

```vue
 <Son title="你好" content="李颖河" :message="msg" :num="9999" :show="false" :arr="[1, 2, 3]"/>
```

​	 i) `对象`	 	 

```vue
<Son title="你好" content="李颖河" :message="msg" :num="9999" :show="false" :arr="[1, 2, 3]" :obj="{a: '张三'}"/>
```

c) 子组件props

props可以为以下类型

 1）数组

```vue
<script>
  export default {
    props: ["title", "content", "message", "num", "show"],
  };
  </script>
```

2）对象

```vue
 <script>
  export default {
    props: {
      title: {
        //title类型为String
        type: String
      },
      content: String,
      //num类型为string或number
      num: [String, Number],
      message:{
        type: String,
        //message默认值
        default:"fuck"
      }
    }
  };
  </script>
```

默认值为对象时，default需为一个函数

```vue
<template>
	<div>{{p1.name}}</div>
</template> 
<script>
  export default {
      p1: {
        type: Object,
        default() {
          return {name: '王二'}
        }
      }
    }
  };
  </script>
```



传递对象时，可以使用`v-bind`直接传递整个对象

```vue
父：
<template>
  <!-- 父传子 -->
  <Son v-bind="people"/>
</template>

<script>
import Son from "./Son.vue";
export default {
  components: {
    Son,
  },
  data() {
    return {
      people: {
        name: '张三',
        age: 88,
        male: 'old man'
      }
    }
  }
};
</script>

子：
	  <template>
    <h1>people</h1>
    <div>{{name}} - {{age}} - {{male}}</div>
  </template>

  <script>
  export default {
    props: {
      name: String,
      age: Number,
      male: String
    }
  };
  </script>

```



props还可以自定义验证器：**validator**

validator函数接受一个参数，改参数为父组件传递的数据

创建一个验证器，验证父组件传递的数据智能为： "王五", "李四", "张三": 

```vue
  <template>
    <h1>{{name}}</h1>
  </template>

  <script>
  export default {
    props: {
      name: {
        validator(value) {
          return ["王五", "李四", "张三"].includes(value);
        },
      }
    }
  };
  </script>

```



**props推荐使用 - ，而不是驼峰**



props为单向数据流，不要尝试在自组件去修改porps的值：

* **这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用**。在这种情况下，最好定义一个本地的 data property 并将这个 prop 作为其初始值

```vue
props: ['initialCounter'],
data() {
  return {
    counter: this.initialCounter
  }
}
```

* **这个 prop 以一种原始的值传入且需要进行转换**。在这种情况下，最好使用这个 prop 的值来定义一个计算属性

```vue
props: ['size'],
computed: {
  normalizedSize() {
    return this.size.trim().toLowerCase()
  }
}
```

> 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身**将会**影响到父组件的状态，且 Vue 无法为此向你发出警告。作为一个通用规则，应该避免修改任何 prop，包括对象和数组，因为这种做法无视了单向数据绑定，且可能会导致意料之外的结果。



##### 自定事件(子传父)

组件和 prop 一样，事件名提供了自动的大小写转换。如果在子组件中触发一个以 camelCase (驼峰式命名) 命名的事件，你将可以在父组件中添加一个 kebab-case (短横线分隔命名) 的监听器。

```vue
//子组件
this.$emit('myEvent')

// 父组件
<my-component @my-event="doSomething"></my-component>
```

* 定义自定义事件

​	使用`emits`定义发出的事件	

```vue
<script>
export default {
  emits: ['add', 'min'],
}
</script>
```

当在 `emits` 选项中定义了原生事件 (如 `click`) 时，将使用组件中的事件**替代**原生事件侦听器。

* 发送事件

​	使用`$emit`发送事件，父组件中在自组件上使用`v-on`接收发送的事件

​	`$emit`可接收参数

```vue
//子组件
<script>
	export default {
    emits: ["submit"],
    methods: {
      click() {
        this.$emit("submit")
      }
    }
  }
</script>

//父组件
<son @submit="sub"></son>
<script>
	export default {
    methods: {
      sub() {
        console.log('这是组件发送到的自定义事件')
      }
    }
  }
</script>
```

* 验证抛出事件

​	传递一个函数给`emits`对自定义事件进行验证

```vue
template>
  <button @click="click">submit</button>
</template>
<script>
export default {
  emits: {
    submit(user, pass) {
      if (!user) {
        console.log("Please enter username");
        return false;
      }
      if (!pass) {
        console.log("Please enter password");
        return false;
      }
      return true;
    },
  },
  methods: {
    click() {
      this.$emit("submit", "zhangsan", "lzpp");
    },
  },
};
</script>
```

#### v-mode更新props

使用v-mode实现父子组件的数据双向绑定：

默认情况下，组件上的 `v-model` 使用 `modelValue` 作为 prop 和 `update:modelValue` 作为事件。我们可以通过向 `v-model` 传递参数来修改这些名称：

```vue
//父组件
<inputs v-model:titles="text" />

//子组件
<template>
  <input type="text" @input="change" />
</template>
<script>
export default {
  props: ["titles"],
  emits: ["update:titles"],
  methods: {
    change(event) {
      this.$emit("update:titles", event.target.value);
    },
  },
};
</script>

```

> 子组件数据更改时会改变父组件数据，使用`v-model`与`update:modelvalue`无需在父组件中绑定自定义事件，更加的简单

* 可以绑定多个v-model参数

```vue
//父组件 
<inputs v-model:titles="text" v-model:fuck="fuckman"   />

//子组件
<template>
  <input type="text" @input="change" />
  <h2>{{ fuck }}</h2>
</template>
<script>
export default {
  props: ["titles", "fuck"],
  emits: ["update:titles", "update:fuck"],
  methods: {
    change(event) {
      this.$emit("update:titles", event.target.value);
      this.$emit("update:fuck", "fuck the world");
    },
  },
};
</script>
```

* 获取父组件v-model属性

a) 子组件可以通过`modelModifiers`对象获取父组件`v-model`修饰符

b) 子组件可以通过`modelValue`获取父组件`v-model`绑定的值

```vue
//父组件
<model v-model.cap="text" />

//子组件
<input type="text" @input="change" :value="modelValue" />
<script>
export default {
	props: {
    // 父组件的v-model值可以通过该属性获得
    modelValue: String,
    // 修饰符可以改对象访问到
		modelModifiers: {
      default: () => {},
    }
	}
  change() {
    console.log(this.modelModifiers)；
    /*
    	modelModifiers: {
    		cap: true
    	}
    */
  }
}
</script>
```



#### 2.attribute继承与多个根组件

* inheritAttrs

​		前提:	一般在父组件中的子组件上添加属性会被添加到自组件的根组件上，有多个子组件则失效

​		使用改属性可以控制改行为

* 多个根组件

​		当子组件有多个根组件时，不会继承attribute，而是会报警告，此时需要`$attrs`手动绑定

```vue
父组件
<Son class="why" names="abc" id="fuck" />

子组件
<h1 :class="$attrs.id">{{ name }}</h1>
```

#### 子孙组件通信

* 使用provide(祖组件) inject(孙组件) 进行传值

```vue
//祖组件
<script>
	provide() {
    return {
      user: "tom",
      length: this.nums.length,
    };
  },
</script>

//孙组件
<script>
	inject: ["user"]
</script>
```

* 当传递`变量`时，provide需写成一个函数并返回一个对象，

```vue
//祖组件
<script>
	export default {
        data() {
            return {
                name: '张三'
            }
        },
        provide() {
            return {
                user: this.name
            }
        }
    }
</script>
//孙组件
<script>
	export default {
        inject: ['user']
    }
</script>
```

