### 1.watch
#### 1.1 作用
在组合式 API 中，使用watch函数去监听`响应式状态`的变化，并触发回调函数

#### 1.2 语法
watch ( 侦听数据，([newv], [oldv]) => {});

#### 1.3 侦听数据来源类型
- ref(包括计算属性)
- 响应式对象(reactive)
  只能侦听整体的响应式对象，不能侦听响应式对象中的单个属性， 如果需要`侦听响应式对象的单个属性，请使用getter函数:`
```js
watch(() => reactive.prop, () => {})
```
- getter函数
- 多个来源组成的数组

#### 1.4 deep
在侦听普通的深层的对象属性时，可以添加 deep 强制转换为深层侦听器，这样就可以侦听到深层的对象属性；

侦听的为响应式对象时，会隐式的创建一个深层侦听器
```js
watch(() => state.obj, () =>{}, {deep: true})
```
> **谨慎使用**
> 深度侦听需要遍历被侦听对象中的所有嵌套的 property，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。


#### 1.5 flush
**作用**
控制watch 回调在vue组件更新之前执行(默认), 还是之后执行；

**使用**
当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。

默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新**之前**被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。

如果想在侦听器回调中能访问被 Vue 更新**之后**的DOM，你需要指明 `flush: 'post'` 选项：
```js
watch(source, callback, {
  flush: 'post'
})
```

### 2.watchEffect
#### 2.1 作用
侦听源变化时，执行回调，与watch作用相同

#### 2.2 与watch的区别
watch 时懒执行的，而 watchEffect 是会立即执行


### 3.停止侦听器
**自动停止**
在 **setup** 或 **script setu**p 中创建的侦听器都是同步创建的，它会自动绑定到当前组件上，在组件卸载时，绑定的侦听器也会销毁；

异步创建的侦听器不会绑定到组件上，不会自动销毁，需要手动销毁以防止内存泄漏

**手动停止**
watch 或 watchEffect 会返回一个函数，调用该函数则会停止当前的侦听器
```js
const stop = watch();
//停止侦听器
stop();

```
