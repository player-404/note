#### 用户

##### 1. 创建用户 & 密码加密

* 创建用户

  创建用户我们放在`authController`文件中，路由为`singUp`，这个路由注册管理员用户，而管理员用户又可以创建子用户与更新用户等操作，所以一般用户创建放在`userController.js`中；

  

  **authController.js**

  ```javascript
  const catchAsync = require("../utils/catchAsync");
  const ErrorHanding = require("../utils/errorHanding");
  const User = require("../models/userModel");
  
  //用户注册
  exports.singup = catchAsync(async (req, res, next) => {
    const newUser = await User.create(req.body);
    if (!newUser) next(new ErrorHanding("用户注册数据失败", 400));
    res.status(200).json({ status: "success", data: { user: newUser } });
  });
  ```

  **userRouters.js**

  ```javascript
  const { singup } = require("../controller/authController");
  // router.param("id", checkUserId);
  
  //用户注册
  router.route("/singUp").post(singup);
  
  ```

  * 密码加密

    密码加密我们放在mongoose中间件中来做，在保存数据之前，对密码进行加密之后再存储在数据控

    注意：

    ​	我们之前在schema中添加了确认密码的自定义验证器

    ```javascript
     passwordConfirm: {
        type: String,
        //验证两次密码是否一致
        validate: {
          validator: function (v) {
            return v === this.password;
          },
          message: "两次密码不一致",
        },
      },
    ```

    我们并不会把确认密码存储在数据库中，只是给他添加验证器，确保用户两次输入的密码一致，所以数据在通过schema验证器后，即将要存储数据库之前，我们把`passwordConfirm`设置为`undefined`，不存储进数据库，当然，schrma `passwordConfirm` 也不能设置为`required`

    

    使用bcryptjs进行加密

    ```javascript
    //密码加密模块
    const bcrypt = require("bcryptjs");
    userSchema.pre("save", async function (next) {
      //isModified 检测文档/文档属性是否修改，修改返回true, 没修改返回false
      if (!this.isModified("password")) {
        console.log("密码已经改变");
        return next();
      }
      //加密密码
      this.password = await bcrypt.hash(this.password, 12);
      //验证密码设置为undefined，不存储在数据库中，只是用来验证两次密码是否一致
      this.passwordConfirm = undefined;
      next();
    });
    ```

    