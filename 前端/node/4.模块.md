## 模块

### 1.一个文件就是一个模块

​	在node.js中，每一个文件实际上就是一个模块

### 2.require

require  =>  引入模块

* 引入模块时，node会优先从缓存中引入模块，避免了重复引入的问题
  * require缓存：node会自动缓存require过的模块,`但是缓存是通过路径判断的，相同文件不同路径会产生两份缓存`
* require引入模块时`同步的`



### 3.exports与module.exports

* require加载的模块通过module.exports暴露

* exports是对module.exports引用：

  ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/16/16c98da07872f7f3~tplv-t2oaga2asx-watermark.image)

* require导出的内容是module.exports的指向的内存块内容，并不是exports的。

> 在使用的时候更建议大家使用module.exports



### 4.将公用代码抽成模块

```javascript
//⚡️创建替换模版字符传函数
function replaceTemplate(temp, product) {
    //每次返回都是前一次替换完成的模版文件（牛批🤙）
    let output = temp.replace(/{%PRODUCTNAME%}/g, product.productName);
    output = output.replace(/{%IMAGE%}/g, product.image);
    output = output.replace(/{%PRICE%}/g, product.price);
    output = output.replace(/{%FROM%}/g, product.from);
    output = output.replace(/{%NUTRIENTS%}/g, product.nutrients);
    output = output.replace(/{%QUANTITY%}/g, product.quantity);
    output = output.replace(/{%DESCRIPTION%}/g, product.description);
    output = output.replace(/{%ID%}/g, product.id);
    if (!product.organic) {
        output = output.replace(/{%NOT_ORGANIC%}/g, 'not-organic');
    }
    return output;
}

module.exports = replaceTemplate;
```

