# 泛型
## 什么是泛型？
可以动态的传入类型注解，使一个变量可以支持多种数据类型，增加代码的重用性

## 使用
使用`<>`创建泛型，可以传入`一个或多个`参数， 参数名自定
```ts
function say<T>(name: T): T {
	return name;
}
```
上诉代码表示say函数的类型为 T(动态传入)，name类型为 T, say函数返回值类型为 T

在调用时传入类型参数
```ts
const name = say<string>('zhangsan')
```
此时泛型T为string，则name类型为string， say函数返回的值类型为string

泛型也可传入多个参数
```ts
function say<T, T1>(name: T, age: T1): T {
	return name;
}
```
调用
```ts
say<string, number>('张三', 12);
```
上述代码 泛型T为string, T1为number，则name类型为string, age类型为number，say函数返回值的类型为number

## 泛型在类中的使用
在class中使用泛型，即在类型之后声明泛型即可
```ts
class Person<T> {
    name: T;
    age: T;
    constructor(name: T, age: T) {
      this.age = age;
      this.name = name;
    }
  }
```
在实例化时，传入泛型类型
```ts
const p = new Person<striing>('张三', "19");
//可以使用以下方法
const p: Person<string> = new Person('张三', "19");
```

## 泛型在接口中的使用
泛型同样可以用在接口中，如以下代码
```ts
//在接中使用泛型
  interface obj<T> {
    name: T;
    says(): T;
  }

  const o: obj<string> = {
    name: "zhangsan",
    says() {
      return this.name;
    },
  };
```

> 函数中未明确传入泛型的类型时，ts会自动推导类型， 其他则不行