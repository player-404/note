
## 接口
定义属性的类型注解，与 `type` 类似，一般用在对象中
```ts
interface obj {
  name: string;
  age: number;
}

const person: obj = {
  name: "张三",
  age: 19,
};
```
可以添加`可选`属性
```ts
interface obj1 {
  name: string;
  age?: number;
}

const p1: obj1 = {
  name: "张三",
};
```

### 索引类型
使用 `[]` 可以定义 `key` 的类型
`索引类型`定义的时属性的通用类型，定义的时对象中的所有属性与值的类型注解
```ts
//定义对象内所有属性的类型为 number, 所有值的类型为 number
interface obj2 {
  [prop: number]: number;
}

const p2: obj2 = {
  0: 1,
  1: 2,
};

//定义对象内所有属性的类型为 string, 所有值的类型为 string
interface obj3 {
  [prop: string]: string;
}
const p3: obj3 = {
    name: '张三',
    age: '19'
}
```

## 接口定义函数
使用接口定义函数
```ts
interface obj4 {
  say(name: string, age: number): string;
}

const obj4: obj4 = {
  say(name: string, age: number) {
    return `${name} + ${age}`;
  },
};
```

## implements
使用`implements`关键字使用`接口`可以对`class`的属性与方法进行限定, `接口内定义的方法属性不可缺少，同时，也可以增加其他属性火方法`
```ts
interface obj5 {
  name: string;
  age: number;
  say(): string;
}
class P implements obj5 {
  name: string;
  age: number;
  person: string;
  constructor(name: string, age: number, person: string) {
    this.name = name;
    this.age = age;
    this.person = person;
  }

  say() {
    return this.name;
  }
}
```
可以使用多个接口对class进行限定, 那么多个接口内的属性或方法必须得有
```ts
interface obj5 {
  name: string;
  age: number;
  say(): string;
}
interface obj6 {
  call(): number;
}
class P implements obj5, obj6 {
  name: string;
  age: number;
  person: string;
  constructor(name: string, age: number, person: string) {
    this.name = name;
    this.age = age;
    this.person = person;
  }

  say() {
    return this.name;
  }

  call() {
    return 3;
  }
}
```

## 接口继承
上面的代码也可以使用`接口继承`，使用关键字`extends`
```ts
interface a {
  name: string;
}
interface b extends a {
  age: number;
}

const p7: b = {
  name: "张三",
  age: 33,
};
```

