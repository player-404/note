### 作用域

* LSH查询：

​	查找变量本身，获取的是变量本身

* RSH查询：

​	查到的是变量的值

* ReferenceError:

  该错误一般是查找的变量不存在，在作用域链中没有查找到，未声明

1. 什么是作用域

   它是一套存储、访问数据的规则：

   内部作用域可以访问外部作用域的变量，而外部作用域不能访问内部作用域的变量，只能向外访问

   当前作用域中的变量或函数只存储在当前作用域的变量对象中

2. 作用域的创建

   作用域是根据代码书写的位置来创建的，发生在编译阶段的词法分析阶段;

   作用域分为*动态作用域*和*词法作用域*，*词法作用域*被大多数编程语言所使用，javaScript使用的也是*词法作用域*;

3. 变量对象

   每个执行上下文都有一个属于自己的**变量对象**，执行上下文中的所有*变量或函数*都会存储在**变量对象**中

   函数上下文中则会将活动对象(arguments)当作变量对象

4. 全局上下文与函数上下文

   * 全局上下文

      浏览器中全局上下文就是指`window`对象，全局对象只有在浏览器关闭，或页面关闭时才会销毁

   * 函数上下文

      当代码执行流进入函数时，函数的上下文被推到上下文栈上，在函数执行完后，上下文栈会弹出函数上下文，将控制权返回给之前的执行上下文

   

### 作用域链

> 上下文中的代码在执行的时候，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码在执行的上下文的变量对象始终位于作用域链的最前端



### 变量声明

1. var声明

   var声明的变量会添加进就近的作用域中，没有var关键字的声明会自动添加进全局作用域中

   var可以重复声明，后声明的变量声明会被忽略：

   > 声明相同的变量时，引擎会进行LSH查询：询问当前作用域中吃否存在该变量，如果存在，则直接‘拿过来’进行赋值操作；如果不存在则会进行声明赋值操作，这是就会形成遮蔽，当作用域链中存在相同的变量时，处于作用域链前端的变量会遮蔽后面的变量

   var声明存在变量提升，var声明会被提升到当前作用域的最前端，因此在声明语句之上获取值，也可以获取到：undefined,只是还未赋值

   ```javascript
   console.log(a); //undefined
   var a = 1;
   
   //等同于
   var a; //变量提升 
   console.log(a);
   a = 1;
   ```

   

2. let声明å

   let声明的作用域是块级的，块级作用域由最近一对`{}`所界定;

   let声明不存在`变量提升`，相反存在`暂时性死区`,变量声明之前无法使用，会报`ReferenceError`错误；

   let不能重复声明

3. const声明

   声明时必须同时赋值

   不能重复声明

   存在块作用域

   声明之后不能再重新赋值，变量的值时单一类型且不可修改
