### 原型链(p238)

实现原型链（继承）：

```javascript
function SuperType() {
    this.property = true;
}

SuperType.prototype.getSuperValue = function() {
    return this.prototype;
}

function SubType() {
    this.subproperty = false;
}

SubType.prototype = new SuperType(); //实现关键：Subtype的原型指向SuperType实例,

SubType.prototype.getSubValue = function() {
    return this.subproperty;
}

let instance = new SubType();

```

<img src="https://cdn.jsdelivr.net/gh/player-404/picture/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0.png" />

> 这个例子实现继承的关键：SubType没有使用默认原型，将其替换成新的对象，这个新的对象恰好是SuperType实例，这样一来，SubType的实例(instance)不仅能从SuperTypede实例中即成属性盒方法，而且还与SuperType的原型挂上钩。



> instance（通过内部的[[prototype]]）指向SubType.prototype，而SubType.prototype（作为SuperType的实例又通过内部的[[prototype]]）指向SuperType.prototype。注意：getSuperValue方法还在SuperType.prototype对象上，而protorype则在SubType.prototype对象上，因为getSuperValue是原型的一个方法，而protorype则是实例的一个属性，SubType.protorype是SuperType的一个实例，所以才会存储在上面。还要注意SubType.prototypede的constructor被重写指向为SuperType，因此实例instance的cinstructor也指向SuperTuype



**每个构造函数都有一个原型对象，原型有一个属性(constructor)指回构造函数，而实例有一个内部指针(_proto_)指向(构造函数的)原型。如果(一个构造函数的)原型是另一个类型(构造函数的)实例，那就意味这个原型本省有一个内部指针(proto)指向另一个原型，相应的，另一个原型也有一个指针(constructor)指向另一个构造函数，这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想**